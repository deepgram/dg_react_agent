{"version":3,"file":"useAudioManager.js","sourceRoot":"","sources":["useAudioManager.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAgBjE,MAAM,UAAU,eAAe,CAC7B,OAAgC,EAChC,OAAoC;IAFtC,iBAiEC;IA/DC,wBAAA,EAAA,YAAoC;IAEpC,QAAQ;IACF,IAAA,KAAoC,QAAQ,CAAC,KAAK,CAAC,EAAlD,aAAa,QAAA,EAAE,gBAAgB,QAAmB,CAAC;IACpD,IAAA,KAAoB,QAAQ,CAAoB,IAAI,CAAC,EAApD,KAAK,QAAA,EAAE,QAAQ,QAAqC,CAAC;IAE5D,mBAAmB;IACnB,IAAM,eAAe,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAEtC,gBAAgB;IAChB,IAAM,WAAW,GAAG,WAAW,CAAC,UAAC,KAAiB;;QAChD,QAAQ,CAAC,KAAK,CAAC,CAAC;QAChB,MAAA,OAAO,CAAC,OAAO,wDAAG,KAAK,CAAC,CAAC;IAC3B,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;IAEtB,oBAAoB;IACpB,IAAM,UAAU,GAAG,WAAW,CAAC;;;;;oBAC7B,IAAI,CAAC,OAAO,EAAE;wBACZ,WAAW,CAAC;4BACV,IAAI,EAAE,YAAY;4BAClB,OAAO,EAAE,4BAA4B;4BACrC,IAAI,EAAE,OAAO;4BACb,IAAI,EAAE,yBAAyB;yBAChC,CAAC,CAAC;wBACH,sBAAO;qBACR;;;;oBAGC,qBAAM,OAAO,CAAC,UAAU,EAAE,EAAA;;oBAA1B,SAA0B,CAAC;oBAC3B,gBAAgB,CAAC,IAAI,CAAC,CAAC;;;;oBAEvB,WAAW,CAAC,OAAmB,CAAC,CAAC;;;;;SAEpC,EAAE,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC;IAE3B,iBAAiB;IACjB,IAAM,OAAO,GAAG,WAAW,CAAC;QAC1B,IAAI,CAAC,OAAO;YAAE,OAAO;QAErB,IAAI;YACF,OAAO,CAAC,OAAO,EAAE,CAAC;YAClB,gBAAgB,CAAC,KAAK,CAAC,CAAC;SACzB;QAAC,OAAO,KAAK,EAAE;YACd,WAAW,CAAC,KAAmB,CAAC,CAAC;SAClC;IACH,CAAC,EAAE,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC,CAAC;IAE3B,qBAAqB;IACrB,SAAS,CAAC;QACR,OAAO;YACL,IAAI,CAAC,eAAe,CAAC,OAAO,IAAI,OAAO,EAAE;gBACvC,eAAe,CAAC,OAAO,GAAG,IAAI,CAAC;gBAC/B,OAAO,EAAE,CAAC;aACX;QACH,CAAC,CAAC;IACJ,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC;IAEvB,OAAO;QACL,UAAU,YAAA;QACV,OAAO,SAAA;QACP,aAAa,eAAA;QACb,KAAK,OAAA;KACN,CAAC;AACJ,CAAC","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\nimport { BaseAudioManager } from '../../utils/shared/BaseAudioManager';\nimport { AudioError } from '../../types/common/error';\n\nexport interface UseAudioManagerOptions {\n  debug?: boolean;\n  onError?: (error: AudioError) => void;\n}\n\nexport interface UseAudioManagerReturn {\n  initialize: () => Promise<void>;\n  cleanup: () => void;\n  isInitialized: boolean;\n  error: AudioError | null;\n}\n\nexport function useAudioManager(\n  manager: BaseAudioManager | null,\n  options: UseAudioManagerOptions = {}\n): UseAudioManagerReturn {\n  // State\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [error, setError] = useState<AudioError | null>(null);\n\n  // Cleanup tracking\n  const isCleaningUpRef = useRef(false);\n\n  // Error handler\n  const handleError = useCallback((error: AudioError) => {\n    setError(error);\n    options.onError?.(error);\n  }, [options.onError]);\n\n  // Initialize method\n  const initialize = useCallback(async () => {\n    if (!manager) {\n      handleError({\n        name: 'AudioError',\n        message: 'Audio manager not provided',\n        type: 'audio',\n        code: 'MANAGER_NOT_INITIALIZED'\n      });\n      return;\n    }\n\n    try {\n      await manager.initialize();\n      setIsInitialized(true);\n    } catch (error) {\n      handleError(error as AudioError);\n    }\n  }, [manager, handleError]);\n\n  // Cleanup method\n  const cleanup = useCallback(() => {\n    if (!manager) return;\n\n    try {\n      manager.cleanup();\n      setIsInitialized(false);\n    } catch (error) {\n      handleError(error as AudioError);\n    }\n  }, [manager, handleError]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (!isCleaningUpRef.current && manager) {\n        isCleaningUpRef.current = true;\n        cleanup();\n      }\n    };\n  }, [manager, cleanup]);\n\n  return {\n    initialize,\n    cleanup,\n    isInitialized,\n    error\n  };\n} "]}