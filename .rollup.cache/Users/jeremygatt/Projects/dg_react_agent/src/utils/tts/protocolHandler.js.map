{"version":3,"file":"protocolHandler.js","sourceRoot":"","sources":["protocolHandler.ts"],"names":[],"mappings":"AAQA;IACE,yBAAoB,OAAoC;QAApC,wBAAA,EAAA,YAAoC;QAApC,YAAO,GAAP,OAAO,CAA6B;IAAG,CAAC;IAIrD,4CAAkB,GAAzB,UAA0B,IAAY;QACpC,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;YACtB,OAAO,CAAC,GAAG,CAAC,oDAAoD,EAAE,IAAI,CAAC,CAAC;SACzE;QAED,OAAO;YACL,IAAI,EAAE,OAAO;YACb,IAAI,MAAA;SACL,CAAC;IACJ,CAAC;IAEM,4CAAkB,GAAzB;QACE,OAAO;YACL,IAAI,EAAE,OAAO;SACd,CAAC;IACJ,CAAC;IAEM,4CAAkB,GAAzB;QACE,OAAO;YACL,IAAI,EAAE,OAAO;SACd,CAAC;IACJ,CAAC;IAEM,4CAAkB,GAAzB;QACE,OAAO;YACL,IAAI,EAAE,OAAO;SACd,CAAC;IACJ,CAAC;IAEM,yCAAe,GAAtB,UAAuB,IAAY,EAAE,YAA2B;QAA3B,6BAAA,EAAA,mBAA2B;QAC9D,6DAA6D;QAC7D,IAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzD,IAAM,MAAM,GAAa,EAAE,CAAC;QAC5B,IAAI,YAAY,GAAG,EAAE,CAAC;QAEtB,KAAuB,UAAS,EAAT,uBAAS,EAAT,uBAAS,EAAT,IAAS,EAAE;YAA7B,IAAM,QAAQ,kBAAA;YACjB,uEAAuE;YACvE,IAAI,YAAY,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,GAAG,YAAY,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;gBACnF,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC;gBACjC,YAAY,GAAG,EAAE,CAAC;aACnB;YACD,YAAY,IAAI,QAAQ,CAAC;SAC1B;QAED,8CAA8C;QAC9C,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;YAC3B,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAC;SAClC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,oCAAU,GAAjB,UAAkB,IAAY;QAC5B,OAAO,iBAAU,IAAI,aAAU,CAAC;IAClC,CAAC;IACH,sBAAC;AAAD,CAAC,AA5DD,IA4DC","sourcesContent":["import { DeepgramTTSMessage } from '../../types/tts';\n\ninterface ProtocolHandlerOptions {\n  debug?: boolean;\n  enableTextChunking?: boolean;\n  maxChunkSize?: number;\n}\n\nexport class ProtocolHandler {\n  constructor(private options: ProtocolHandlerOptions = {}) {}\n\n\n\n  public createSpeakMessage(text: string): DeepgramTTSMessage {\n    if (this.options.debug) {\n      console.log('[ProtocolHandler] Creating speak message for text:', text);\n    }\n    \n    return {\n      type: 'Speak',\n      text\n    };\n  }\n\n  public createFlushMessage(): DeepgramTTSMessage {\n    return {\n      type: 'Flush'\n    };\n  }\n\n  public createClearMessage(): DeepgramTTSMessage {\n    return {\n      type: 'Clear'\n    };\n  }\n\n  public createCloseMessage(): DeepgramTTSMessage {\n    return {\n      type: 'Close'\n    };\n  }\n\n  public chunkBySentence(text: string, maxChunkSize: number = 1000): string[] {\n    // Split text into sentences using common sentence delimiters\n    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];\n    const chunks: string[] = [];\n    let currentChunk = '';\n\n    for (const sentence of sentences) {\n      // If adding this sentence would exceed maxChunkSize, start a new chunk\n      if (currentChunk.length + sentence.length > maxChunkSize && currentChunk.length > 0) {\n        chunks.push(currentChunk.trim());\n        currentChunk = '';\n      }\n      currentChunk += sentence;\n    }\n\n    // Add the last chunk if there's anything left\n    if (currentChunk.length > 0) {\n      chunks.push(currentChunk.trim());\n    }\n\n    return chunks;\n  }\n\n  public wrapInSSML(text: string): string {\n    return `<speak>${text}</speak>`;\n  }\n} "]}