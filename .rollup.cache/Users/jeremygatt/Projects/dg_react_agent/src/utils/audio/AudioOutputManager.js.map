{"version":3,"file":"AudioOutputManager.js","sourceRoot":"","sources":["AudioOutputManager.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,gBAAgB,EAAmD,MAAM,4BAA4B,CAAC;AAC/G,OAAO,EAAE,iBAAiB,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAUlE;IAAwC,sCAAgB;IAKtD,4BACE,OAAuC,EACvC,QAAuC;QADvC,wBAAA,EAAA,YAAuC;QACvC,yBAAA,EAAA,aAAuC;QAFzC,YAIE,kBAAM,OAAO,EAAE,QAAQ,CAAC,SACzB;QATO,kBAAY,GAAG,EAAE,OAAO,EAAE,CAAC,EAAE,CAAC;QAC9B,mBAAa,GAAiC,IAAI,CAAC;QACnD,eAAS,GAAG,KAAK,CAAC;;IAO1B,CAAC;IAEe,4CAAe,GAA/B,UAAgC,IAAiB;;;;;;gBAC/C,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;oBACtB,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;iBAClD;gBAED,IAAI;oBACI,MAAM,GAAG,iBAAiB,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;oBAC1D,IAAI,CAAC,MAAM,EAAE;wBACX,sBAAO;qBACR;oBAEK,MAAM,GAAG,eAAe,CAC5B,IAAI,CAAC,YAAY,EACjB,MAAM,EACN,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,QAAQ,IAAI,SAAS,CAC3B,CAAC;oBAEF,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC;oBAC5B,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;oBAEtB,MAAM,CAAC,OAAO,GAAG;;wBACf,KAAI,CAAC,SAAS,GAAG,KAAK,CAAC;wBACvB,KAAI,CAAC,aAAa,GAAG,IAAI,CAAC;wBAC1B,MAAA,MAAA,KAAI,CAAC,QAAQ,EAAC,UAAU,kDAAI,CAAC;oBAC/B,CAAC,CAAC;oBAEF,MAAA,MAAA,IAAI,CAAC,QAAQ,EAAC,YAAY,kDAAI,CAAC;iBAChC;gBAAC,OAAO,KAAK,EAAE;oBACd,IAAI,CAAC,WAAW,CAAC,KAAc,EAAE,iBAAiB,CAAC,CAAC;oBACpD,MAAM,KAAK,CAAC;iBACb;;;;KACF;IAEY,uCAAU,GAAvB,UAAwB,IAAiB;;;gBACvC,sBAAO,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,EAAC;;;KACnC;IAEM,iCAAI,GAAX;QACE,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;YAC1B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;SAC3B;QACD,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,IAAI,CAAC,YAAY,CAAC,OAAO,GAAG,CAAC,CAAC;IAChC,CAAC;IAEM,4CAAe,GAAtB;QACE,IAAI,CAAC,IAAI,EAAE,CAAC;IACd,CAAC;IAEM,yCAAY,GAAnB;QACE,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAEe,oCAAO,GAAvB;QACE,IAAI,CAAC,IAAI,EAAE,CAAC;QACZ,iBAAM,OAAO,WAAE,CAAC;IAClB,CAAC;IACH,yBAAC;AAAD,CAAC,AAvED,CAAwC,gBAAgB,GAuEvD","sourcesContent":["import { BaseAudioManager, BaseAudioManagerOptions, BaseAudioEventHandlers } from '../shared/BaseAudioManager';\nimport { createAudioBuffer, playAudioBuffer } from './AudioUtils';\n\nexport interface AudioOutputManagerOptions extends BaseAudioManagerOptions {\n  // Add any TTS-specific options here\n}\n\nexport interface AudioOutputEventHandlers extends BaseAudioEventHandlers {\n  // Add any TTS-specific handlers here\n}\n\nexport class AudioOutputManager extends BaseAudioManager {\n  private startTimeRef = { current: 0 };\n  private currentSource: AudioBufferSourceNode | null = null;\n  private isPlaying = false;\n\n  constructor(\n    options: AudioOutputManagerOptions = {},\n    handlers: AudioOutputEventHandlers = {}\n  ) {\n    super(options, handlers);\n  }\n\n  protected async handleAudioData(data: ArrayBuffer): Promise<void> {\n    if (!this.audioContext) {\n      throw new Error('Audio context not initialized');\n    }\n\n    try {\n      const buffer = createAudioBuffer(this.audioContext, data);\n      if (!buffer) {\n        return;\n      }\n\n      const source = playAudioBuffer(\n        this.audioContext,\n        buffer,\n        this.startTimeRef,\n        this.analyzer || undefined\n      );\n\n      this.currentSource = source;\n      this.isPlaying = true;\n\n      source.onended = () => {\n        this.isPlaying = false;\n        this.currentSource = null;\n        this.handlers.onAudioEnd?.();\n      };\n\n      this.handlers.onAudioStart?.();\n    } catch (error) {\n      this.handleError(error as Error, 'handleAudioData');\n      throw error;\n    }\n  }\n\n  public async queueAudio(data: ArrayBuffer): Promise<void> {\n    return this.handleAudioData(data);\n  }\n\n  public stop(): void {\n    if (this.currentSource) {\n      this.currentSource.stop();\n      this.currentSource = null;\n    }\n    this.isPlaying = false;\n    this.startTimeRef.current = 0;\n  }\n\n  public clearAudioQueue(): void {\n    this.stop();\n  }\n\n  public getIsPlaying(): boolean {\n    return this.isPlaying;\n  }\n\n  public override cleanup(): void {\n    this.stop();\n    super.cleanup();\n  }\n} "]}