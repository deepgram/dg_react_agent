{"version":3,"file":"MicrophoneManager.js","sourceRoot":"","sources":["MicrophoneManager.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  MicrophoneConfig,\n  MicrophoneState,\n  MicrophoneEventHandlers,\n  MicrophonePermissionResult,\n  AudioWorkletMessage,\n  DEFAULT_MICROPHONE_CONFIG\n} from '../../types/common/microphone';\n\nexport class MicrophoneManager {\n  private audioContext: AudioContext | null = null;\n  private mediaStream: MediaStream | null = null;\n  private sourceNode: MediaStreamAudioSourceNode | null = null;\n  private workletNode: AudioWorkletNode | null = null;\n  private state: MicrophoneState;\n  private config: MicrophoneConfig;\n  private handlers: MicrophoneEventHandlers;\n\n  constructor(\n    config: Partial<MicrophoneConfig> = {},\n    handlers: MicrophoneEventHandlers = {}\n  ) {\n    this.config = { ...DEFAULT_MICROPHONE_CONFIG, ...config };\n    this.handlers = handlers;\n    this.state = {\n      isInitialized: false,\n      isRecording: false,\n      hasPermission: false,\n      permissionState: null,\n      error: null\n    };\n  }\n\n  private log(message: string, data?: any): void {\n    if (this.config.debug) {\n      console.log(`[MicrophoneManager] ${message}`, data || '');\n    }\n  }\n\n  private handleError(error: Error, context: string): void {\n    this.state.error = `${context}: ${error.message}`;\n    this.log(`Error in ${context}:`, error);\n    this.handlers.onError?.(error);\n  }\n\n  public async checkPermissions(): Promise<MicrophonePermissionResult> {\n    try {\n      // Check if permissions API is available\n      if (!navigator.permissions) {\n        // Fallback: try to access microphone directly\n        this.log('Permissions API not available, attempting direct access');\n        return this.requestPermissionFallback();\n      }\n\n      const permissionStatus = await navigator.permissions.query({ \n        name: 'microphone' as PermissionName \n      });\n      \n      this.state.permissionState = permissionStatus.state;\n      this.state.hasPermission = permissionStatus.state === 'granted';\n\n      // Listen for permission changes\n      permissionStatus.addEventListener('change', () => {\n        this.state.permissionState = permissionStatus.state;\n        this.state.hasPermission = permissionStatus.state === 'granted';\n        this.handlers.onPermissionChange?.(permissionStatus.state);\n      });\n\n      this.log('Permission status:', permissionStatus.state);\n\n      return {\n        granted: this.state.hasPermission,\n        state: permissionStatus.state\n      };\n    } catch (error) {\n      this.log('Permission check failed, falling back to direct access');\n      return this.requestPermissionFallback();\n    }\n  }\n\n  private async requestPermissionFallback(): Promise<MicrophonePermissionResult> {\n    try {\n      // Try to get user media to test permissions\n      const testStream = await navigator.mediaDevices.getUserMedia({\n        audio: { channelCount: 1 }\n      });\n      \n      // If successful, we have permission\n      testStream.getTracks().forEach(track => track.stop());\n      \n      this.state.hasPermission = true;\n      this.state.permissionState = 'granted';\n      \n      return {\n        granted: true,\n        state: 'granted'\n      };\n    } catch (error) {\n      const err = error as DOMException;\n      let permissionState: PermissionState = 'prompt';\n      \n      if (err.name === 'NotAllowedError') {\n        permissionState = 'denied';\n      }\n      \n      this.state.hasPermission = false;\n      this.state.permissionState = permissionState;\n      \n      return {\n        granted: false,\n        state: permissionState,\n        error: err.message\n      };\n    }\n  }\n\n  public async initialize(): Promise<void> {\n    try {\n      this.log('Initializing microphone manager');\n\n      // Create audio context with optimal settings (no permission needed for this)\n      this.audioContext = new AudioContext({\n        sampleRate: this.config.constraints.sampleRate,\n        latencyHint: this.config.constraints.latency || 'interactive'\n      });\n\n      // Resume audio context if it's suspended\n      if (this.audioContext.state === 'suspended') {\n        await this.audioContext.resume();\n      }\n\n      // Load the audio worklet processor\n      await this.loadAudioWorklet();\n\n      this.state.isInitialized = true;\n      this.state.error = null;\n      \n      this.log('Microphone manager initialized successfully');\n      this.handlers.onInitialized?.();\n    } catch (error) {\n      this.handleError(error as Error, 'initialize');\n      throw error;\n    }\n  }\n\n  private async loadAudioWorklet(): Promise<void> {\n    if (!this.audioContext) {\n      throw new Error('Audio context not initialized');\n    }\n\n    // Use inline worklet for better compatibility\n    this.log('Loading inline audio worklet processor');\n    await this.loadInlineWorklet();\n    this.log('Audio worklet loaded successfully');\n  }\n\n  private async loadInlineWorklet(): Promise<void> {\n    if (!this.audioContext) {\n      throw new Error('Audio context not initialized');\n    }\n\n    // Create worklet processor code as a string\n    const workletCode = `\n/**\n * Inline AudioWorkletProcessor for microphone capture and processing\n */\nclass MicrophoneProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    \n    // State\n    this.isRecording = false;\n    this.sampleRate = 48000; // Target sample rate\n    this.bufferSize = 4096;  // Buffer size in samples\n    this.buffer = new Float32Array(this.bufferSize);\n    this.bufferIndex = 0;\n    \n    // Set up message handler\n    this.port.onmessage = (event) => this.onMessage(event.data);\n  }\n  \n  /**\n   * Handles messages from the main thread\n   */\n  onMessage(message) {\n    if (message.type === 'start') {\n      this.isRecording = true;\n      this.port.postMessage({ type: 'started' });\n    } else if (message.type === 'stop') {\n      this.isRecording = false;\n      this.port.postMessage({ type: 'stopped' });\n    }\n  }\n  \n  /**\n   * Processes audio input and sends it to the main thread\n   */\n  process(inputs, outputs, parameters) {\n    if (!this.isRecording || !inputs[0] || !inputs[0][0]) {\n      return true;\n    }\n    \n    const input = inputs[0][0];\n    \n    // Add input samples to our buffer\n    for (let i = 0; i < input.length; i++) {\n      this.buffer[this.bufferIndex++] = input[i];\n      \n      // When buffer is full, send it to the main thread\n      if (this.bufferIndex >= this.bufferSize) {\n        this.sendBufferToMainThread();\n        this.bufferIndex = 0;\n      }\n    }\n    \n    return true;\n  }\n  \n  /**\n   * Converts the buffer to the required format and sends it to the main thread\n   */\n  sendBufferToMainThread() {\n    // Create a copy of the buffer\n    const audioData = this.buffer.slice(0, this.bufferIndex);\n    \n    // Convert to 16-bit PCM\n    const pcmData = new Int16Array(audioData.length);\n    for (let i = 0; i < audioData.length; i++) {\n      // Convert float [-1.0, 1.0] to 16-bit PCM [-32768, 32767]\n      const s = Math.max(-1, Math.min(1, audioData[i]));\n      pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;\n    }\n    \n    // Send the PCM data to the main thread\n    this.port.postMessage({\n      type: 'audio',\n      data: pcmData.buffer\n    }, [pcmData.buffer]);\n  }\n}\n\n// Register the processor\nregisterProcessor('microphone-processor', MicrophoneProcessor);\n`;\n\n    // Create blob URL for the worklet\n    const blob = new Blob([workletCode], { type: 'application/javascript' });\n    const workletUrl = URL.createObjectURL(blob);\n\n    try {\n      await this.audioContext.audioWorklet.addModule(workletUrl);\n    } finally {\n      // Clean up the blob URL\n      URL.revokeObjectURL(workletUrl);\n    }\n  }\n\n  public async startRecording(): Promise<void> {\n    if (!this.state.isInitialized || !this.audioContext) {\n      throw new Error('Microphone manager not initialized');\n    }\n\n    if (this.state.isRecording) {\n      this.log('Already recording');\n      return;\n    }\n\n    try {\n      this.log('Starting microphone recording');\n\n      // Get user media\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({\n        audio: this.config.constraints\n      });\n\n      // Create source node\n      this.sourceNode = this.audioContext.createMediaStreamSource(this.mediaStream);\n\n      // Create worklet node\n      this.workletNode = new AudioWorkletNode(\n        this.audioContext,\n        'microphone-processor',\n        {\n          numberOfInputs: 1,\n          numberOfOutputs: 0,\n          channelCount: this.config.constraints.channelCount || 1\n        }\n      );\n\n      // Set up worklet message handling\n      this.workletNode.port.onmessage = (event) => {\n        this.handleWorkletMessage(event.data);\n      };\n\n      // Connect the audio graph\n      this.sourceNode.connect(this.workletNode);\n\n      // Start the worklet processor\n      this.workletNode.port.postMessage({ type: 'start' });\n\n      this.state.isRecording = true;\n      this.state.error = null;\n      \n      this.log('Recording started successfully');\n      this.handlers.onRecordingStart?.();\n    } catch (error) {\n      this.handleError(error as Error, 'startRecording');\n      throw error;\n    }\n  }\n\n  public stopRecording(): void {\n    if (!this.state.isRecording) {\n      this.log('Not currently recording');\n      return;\n    }\n\n    try {\n      this.log('Stopping microphone recording');\n\n      // Stop the worklet processor\n      if (this.workletNode) {\n        this.workletNode.port.postMessage({ type: 'stop' });\n        this.workletNode.disconnect();\n        this.workletNode = null;\n      }\n\n      // Disconnect source node\n      if (this.sourceNode) {\n        this.sourceNode.disconnect();\n        this.sourceNode = null;\n      }\n\n      // Stop media stream\n      if (this.mediaStream) {\n        this.mediaStream.getTracks().forEach(track => track.stop());\n        this.mediaStream = null;\n      }\n\n      this.state.isRecording = false;\n      this.state.error = null;\n      \n      this.log('Recording stopped successfully');\n      this.handlers.onRecordingStop?.();\n    } catch (error) {\n      this.handleError(error as Error, 'stopRecording');\n    }\n  }\n\n  private handleWorkletMessage(message: AudioWorkletMessage): void {\n    switch (message.type) {\n      case 'started':\n        this.log('Worklet processor started');\n        break;\n      case 'stopped':\n        this.log('Worklet processor stopped');\n        break;\n      case 'audio':\n        if (message.data) {\n          this.handlers.onAudioData?.(message.data);\n        }\n        break;\n      default:\n        this.log('Unknown worklet message:', message);\n    }\n  }\n\n  public getState(): MicrophoneState {\n    return { ...this.state };\n  }\n\n  public isRecording(): boolean {\n    return this.state.isRecording;\n  }\n\n  public isInitialized(): boolean {\n    return this.state.isInitialized;\n  }\n\n  public hasPermission(): boolean {\n    return this.state.hasPermission;\n  }\n\n  public getAudioContext(): AudioContext | null {\n    return this.audioContext;\n  }\n\n  public cleanup(): void {\n    this.log('Cleaning up microphone manager');\n    \n    this.stopRecording();\n    \n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    \n    this.state.isInitialized = false;\n    this.state.hasPermission = false;\n    this.state.permissionState = null;\n    this.state.error = null;\n  }\n} "]}